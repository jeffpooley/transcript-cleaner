<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTT Transcript Cleaner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            background-color: #f5f5f5;
        }

        header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        input[type="file"] {
            display: block;
            margin-bottom: 10px;
            padding: 8px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0051D5;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .results {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .results.visible {
            display: block;
        }

        .report {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #007AFF;
        }

        .report h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .report ul {
            list-style-position: inside;
            color: #666;
        }

        .report li {
            margin-bottom: 5px;
        }

        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .diff-panel {
            background: #f9f9f9;
            border-radius: 6px;
            overflow: hidden;
        }

        .diff-header {
            background: #333;
            color: white;
            padding: 10px 15px;
            font-weight: 500;
        }

        .diff-content {
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .original {
            border: 2px solid #FF3B30;
        }

        .corrected {
            border: 2px solid #34C759;
        }

        .download-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .secondary-button {
            background-color: #8E8E93;
        }

        .secondary-button:hover {
            background-color: #636366;
        }

        .error {
            background-color: #FFEBEE;
            color: #C62828;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #C62828;
        }

        .info {
            background-color: #E3F2FD;
            color: #1565C0;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1565C0;
        }
    </style>
</head>
<body>
    <header>
        <h1>VTT Transcript Cleaner</h1>
        <p class="subtitle">Clean and restructure oral history transcripts with speaker turn timestamps</p>
    </header>

    <div class="controls">
        <div class="file-input-group">
            <label for="vttFile">Select VTT Transcript File:</label>
            <input type="file" id="vttFile" accept=".vtt">
        </div>

        <div class="file-input-group">
            <label for="dictFile">Select Dictionary File (optional):</label>
            <input type="file" id="dictFile" accept=".json">
        </div>

        <button id="processBtn" disabled>Process Transcript</button>
    </div>

    <div id="results" class="results">
        <div id="report" class="report"></div>

        <div class="diff-container">
            <div class="diff-panel original">
                <div class="diff-header">Original</div>
                <div id="originalContent" class="diff-content"></div>
            </div>
            <div class="diff-panel corrected">
                <div class="diff-header">Corrected</div>
                <div id="correctedContent" class="diff-content"></div>
            </div>
        </div>

        <div class="download-buttons">
            <button id="downloadBtn">Download Corrected VTT</button>
            <button id="downloadReportBtn" class="secondary-button">Download Report</button>
        </div>
    </div>

    <script>
        let vttContent = null;
        let dictionary = {};
        let correctedVTT = null;
        let changeReport = null;
        let originalFilename = '';

        const vttFileInput = document.getElementById('vttFile');
        const dictFileInput = document.getElementById('dictFile');
        const processBtn = document.getElementById('processBtn');
        const resultsDiv = document.getElementById('results');
        const reportDiv = document.getElementById('report');
        const originalContentDiv = document.getElementById('originalContent');
        const correctedContentDiv = document.getElementById('correctedContent');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadReportBtn = document.getElementById('downloadReportBtn');

        // Hard-coded filler words to remove
        const FILLER_WORDS = ['uh', 'um', 'uh,', 'um,'];

        vttFileInput.addEventListener('change', handleVTTFile);
        dictFileInput.addEventListener('change', handleDictFile);
        processBtn.addEventListener('click', processTranscript);
        downloadBtn.addEventListener('click', downloadCorrectedVTT);
        downloadReportBtn.addEventListener('click', downloadReport);

        async function handleVTTFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                vttContent = await file.text();
                processBtn.disabled = false;
            }
        }

        async function handleDictFile(event) {
            const file = event.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    dictionary = JSON.parse(text);
                    console.log('Dictionary loaded:', Object.keys(dictionary).length, 'entries');
                } catch (error) {
                    alert('Error loading dictionary file: ' + error.message);
                    dictionary = {};
                }
            }
        }

        function parseVTT(content) {
            const lines = content.split('\n');
            const cues = [];
            let i = 0;

            // Skip header
            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            // Parse cues
            while (i < lines.length) {
                if (lines[i].includes('-->')) {
                    const timeLine = lines[i];
                    const [startTime, endTime] = timeLine.split('-->').map(t => t.trim());

                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        text += (text ? '\n' : '') + lines[i];
                        i++;
                    }

                    cues.push({ startTime, endTime, text });
                }
                i++;
            }

            return cues;
        }

        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            const seconds = parseFloat(parts[2]);
            return hours * 3600 + minutes * 60 + seconds;
        }

        function secondsToTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;
        }

        function applyTextCorrections(text, changes) {
            let corrected = text;

            // Apply dictionary substitutions (case-insensitive)
            for (const [wrong, correct] of Object.entries(dictionary)) {
                const regex = new RegExp('\\b' + wrong.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.dictionaryReplacements += matches.length;
                    corrected = corrected.replace(regex, correct);
                }
            }

            // Remove filler words
            for (const filler of FILLER_WORDS) {
                const regex = new RegExp('\\b' + filler.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.fillerWordsRemoved += matches.length;
                    corrected = corrected.replace(regex, '');
                }
            }

            // Replace double hyphens with em-dash (removing spaces on either side)
            const emDashMatches = corrected.match(/\s*--\s*/g);
            if (emDashMatches) {
                changes.emDashReplacements += emDashMatches.length;
                corrected = corrected.replace(/\s*--\s*/g, 'â€”');
            }

            // Clean up extra spaces
            corrected = corrected.replace(/\s+/g, ' ').trim();

            return corrected;
        }

        function findSentenceBreak(text, targetPosition) {
            // Try to find a sentence ending near the target position
            const searchWindow = 100; // Look 100 chars before and after
            const start = Math.max(0, targetPosition - searchWindow);
            const end = Math.min(text.length, targetPosition + searchWindow);
            const segment = text.substring(start, end);

            // Look for period, question mark, or exclamation
            const sentenceEndings = ['. ', '? ', '! '];
            let bestBreak = -1;
            let minDistance = Infinity;

            for (const ending of sentenceEndings) {
                let pos = segment.indexOf(ending);
                while (pos !== -1) {
                    const actualPos = start + pos + ending.length;
                    const distance = Math.abs(actualPos - targetPosition);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestBreak = actualPos;
                    }
                    pos = segment.indexOf(ending, pos + 1);
                }
            }

            // If we found a good break, use it; otherwise use target position
            return bestBreak !== -1 ? bestBreak : targetPosition;
        }

        function restructureTimestamps(cues) {
            // Combine all text first
            const fullText = cues.map(c => c.text).join('\n');
            const startTime = cues[0].startTime;
            const totalDuration = timeToSeconds(cues[cues.length - 1].endTime);

            // Split by speaker turns
            const paragraphs = fullText.split('\n\n');
            const newCues = [];
            let currentTime = timeToSeconds(startTime);

            for (const para of paragraphs) {
                if (!para.trim()) continue;

                // Check if this is a speaker turn (starts with NAME:)
                const speakerMatch = para.match(/^([A-Z\s]+):\s*/);

                if (speakerMatch) {
                    const speakerText = para;
                    const charCount = speakerText.length;

                    // Estimate duration based on character count (rough approximation)
                    // Average speaking rate: ~150 words/min = ~750 chars/min = ~12.5 chars/sec
                    const estimatedDuration = charCount / 12.5;

                    // If longer than 2 minutes (120 seconds), split it
                    if (estimatedDuration > 120) {
                        const numSegments = Math.ceil(estimatedDuration / 120);
                        const segmentDuration = estimatedDuration / numSegments;
                        const charsPerSegment = Math.floor(charCount / numSegments);

                        let remainingText = speakerText;
                        let segmentStart = currentTime;

                        for (let i = 0; i < numSegments; i++) {
                            const isLastSegment = (i === numSegments - 1);
                            let segmentText;

                            if (isLastSegment) {
                                segmentText = remainingText;
                            } else {
                                const breakPoint = findSentenceBreak(remainingText, charsPerSegment);
                                segmentText = remainingText.substring(0, breakPoint).trim();
                                remainingText = remainingText.substring(breakPoint).trim();
                            }

                            const segmentEnd = segmentStart + segmentDuration;

                            newCues.push({
                                startTime: secondsToTime(segmentStart),
                                endTime: secondsToTime(segmentEnd),
                                text: segmentText
                            });

                            segmentStart = segmentEnd;
                        }

                        currentTime = segmentStart;
                    } else {
                        const endTime = currentTime + estimatedDuration;
                        newCues.push({
                            startTime: secondsToTime(currentTime),
                            endTime: secondsToTime(endTime),
                            text: speakerText
                        });
                        currentTime = endTime;
                    }
                } else {
                    // Non-speaker text, add as-is with estimated timing
                    const charCount = para.length;
                    const estimatedDuration = charCount / 12.5;
                    const endTime = currentTime + estimatedDuration;

                    newCues.push({
                        startTime: secondsToTime(currentTime),
                        endTime: secondsToTime(endTime),
                        text: para
                    });
                    currentTime = endTime;
                }
            }

            return newCues;
        }

        function processTranscript() {
            if (!vttContent) return;

            const changes = {
                dictionaryReplacements: 0,
                fillerWordsRemoved: 0,
                emDashReplacements: 0,
                timestampBlocks: 0,
                segmentsSplit: 0
            };

            try {
                // Parse VTT
                const cues = parseVTT(vttContent);
                changes.originalCues = cues.length;

                // Apply text corrections to each cue
                const correctedCues = cues.map(cue => ({
                    ...cue,
                    text: applyTextCorrections(cue.text, changes)
                }));

                // Restructure timestamps
                const restructuredCues = restructureTimestamps(correctedCues);
                changes.timestampBlocks = restructuredCues.length;
                changes.segmentsSplit = changes.timestampBlocks - changes.originalCues;

                // Generate new VTT
                correctedVTT = 'WEBVTT\n\n' + restructuredCues.map((cue, index) =>
                    `${index + 1}\n${cue.startTime} --> ${cue.endTime}\n${cue.text}\n`
                ).join('\n');

                // Generate report
                changeReport = `VTT Transcript Cleaner - Processing Report
Generated: ${new Date().toLocaleString()}
Original File: ${originalFilename}

Changes Applied:
- Dictionary substitutions: ${changes.dictionaryReplacements}
- Filler words removed: ${changes.fillerWordsRemoved}
- Em-dashes replaced: ${changes.emDashReplacements}
- Original cue blocks: ${changes.originalCues}
- New timestamp blocks: ${changes.timestampBlocks}
- Segments restructured: ${changes.segmentsSplit}

Dictionary entries used: ${Object.keys(dictionary).length}
`;

                // Display results
                displayResults(changes);

            } catch (error) {
                alert('Error processing transcript: ' + error.message);
                console.error(error);
            }
        }

        function displayResults(changes) {
            // Show report
            reportDiv.innerHTML = `
                <h3>Processing Complete</h3>
                <ul>
                    <li>Dictionary substitutions: ${changes.dictionaryReplacements}</li>
                    <li>Filler words removed: ${changes.fillerWordsRemoved}</li>
                    <li>Em-dashes replaced: ${changes.emDashReplacements}</li>
                    <li>Original cue blocks: ${changes.originalCues}</li>
                    <li>New timestamp blocks: ${changes.timestampBlocks}</li>
                    <li>Segments restructured: ${changes.segmentsSplit}</li>
                </ul>
            `;

            // Show diff
            originalContentDiv.textContent = vttContent;
            correctedContentDiv.textContent = correctedVTT;

            // Show results section
            resultsDiv.classList.add('visible');

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function downloadCorrectedVTT() {
            if (!correctedVTT) return;

            const filename = originalFilename.replace('.vtt', '_corrected.vtt');
            const blob = new Blob([correctedVTT], { type: 'text/vtt' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadReport() {
            if (!changeReport) return;

            const filename = originalFilename.replace('.vtt', '_report.txt');
            const blob = new Blob([changeReport], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
