<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTT Transcript Cleaner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            background-color: #f5f5f5;
        }

        header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        input[type="file"] {
            display: block;
            margin-bottom: 10px;
            padding: 8px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0051D5;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .results {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .results.visible {
            display: block;
        }

        .report {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #007AFF;
        }

        .report h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .report ul {
            list-style-position: inside;
            color: #666;
        }

        .report li {
            margin-bottom: 5px;
        }

        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .diff-panel {
            background: #f9f9f9;
            border-radius: 6px;
            overflow: hidden;
        }

        .diff-header {
            background: #333;
            color: white;
            padding: 10px 15px;
            font-weight: 500;
        }

        .diff-content {
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .proper-name {
            color: #0066cc;
            font-weight: 500;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .original {
            border: 2px solid #FF3B30;
        }

        .corrected {
            border: 2px solid #34C759;
        }

        .diff-deleted {
            background-color: #ffcccc;
            text-decoration: line-through;
            padding: 2px 0;
        }

        .diff-added {
            background-color: #ccffcc;
            padding: 2px 0;
        }

        .download-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .secondary-button {
            background-color: #8E8E93;
        }

        .secondary-button:hover {
            background-color: #636366;
        }

        .error {
            background-color: #FFEBEE;
            color: #C62828;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #C62828;
        }

        .info {
            background-color: #E3F2FD;
            color: #1565C0;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1565C0;
        }

        .dictionary-manager {
            margin-top: 15px;
        }

        .dictionary-manager h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .dictionary-manager h4 {
            margin-bottom: 10px;
            color: #555;
            font-size: 14px;
        }

        .add-entry {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }

        .add-entry input[type="text"] {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .add-entry .arrow {
            color: #666;
            font-weight: bold;
        }

        .custom-entries {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .entries-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .entry-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .entry-text {
            font-size: 14px;
            color: #333;
        }

        .entry-delete {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .entry-delete:hover {
            background: #cc0000;
        }
    </style>
</head>
<body>
    <header>
        <h1>VTT Transcript Cleaner</h1>
        <p class="subtitle">Clean and restructure oral history transcripts with speaker turn timestamps</p>
    </header>

    <div class="controls">
        <div class="file-input-group">
            <label for="vttFile">Select VTT Transcript File:</label>
            <input type="file" id="vttFile" accept=".vtt">
        </div>

        <button id="processBtn" disabled>Process Transcript</button>
    </div>

    <div class="controls">
        <h3>Dictionary Manager</h3>
        <div class="dictionary-manager">
            <div class="add-entry">
                <input type="text" id="incorrectWord" placeholder="Incorrect word/phrase" />
                <span class="arrow">→</span>
                <input type="text" id="correctWord" placeholder="Correct version" />
                <button id="addEntryBtn">Add to Dictionary</button>
            </div>

            <div id="customEntries" class="custom-entries">
                <h4>Custom Additions (<span id="entryCount">0</span>)</h4>
                <div id="entriesList" class="entries-list"></div>
            </div>

            <button id="downloadDictBtn" class="secondary-button">Download Updated Dictionary</button>
        </div>
    </div>

    <div class="controls">
        <h3>Acronym Manager</h3>
        <div class="dictionary-manager">
            <div class="add-entry">
                <input type="text" id="acronymShort" placeholder="Acronym (e.g., FTC)" />
                <span class="arrow">→</span>
                <input type="text" id="acronymFull" placeholder="Full name (e.g., Federal Trade Commission)" />
                <button id="addAcronymBtn">Add to Acronyms</button>
            </div>

            <div id="customAcronyms" class="custom-entries">
                <h4>Custom Additions (<span id="acronymCount">0</span>)</h4>
                <div id="acronymsList" class="entries-list"></div>
            </div>

            <button id="downloadAcronymsBtn" class="secondary-button">Download Updated Acronyms</button>
        </div>
    </div>

    <div id="results" class="results">
        <div id="report" class="report"></div>

        <div class="diff-container">
            <div class="diff-panel original">
                <div class="diff-header">Original</div>
                <div id="originalContent" class="diff-content"></div>
            </div>
            <div class="diff-panel corrected">
                <div class="diff-header">Corrected</div>
                <div id="correctedContent" class="diff-content"></div>
            </div>
        </div>

        <div class="download-buttons">
            <button id="downloadBtn">Download Corrected VTT</button>
            <button id="downloadReportBtn" class="secondary-button">Download Report</button>
        </div>
    </div>

    <script>
        let vttContent = null;
        let correctedVTT = null;
        let changeReport = null;
        let originalFilename = '';

        // Dictionary and acronyms - loaded from external JSON files at startup
        let dictionary = {};
        let ACRONYMS = {};

        // Acronyms to exclude from expansion (too common or single letters)
        const ACRONYM_EXCLUSIONS = ['TV', 'US', 'UK', 'OK', 'AM', 'PM', 'A', 'I'];

        // Track which acronyms have been expanded in current transcript
        let expandedAcronyms = new Set();

        const vttFileInput = document.getElementById('vttFile');
        const processBtn = document.getElementById('processBtn');
        const resultsDiv = document.getElementById('results');
        const reportDiv = document.getElementById('report');
        const originalContentDiv = document.getElementById('originalContent');
        const correctedContentDiv = document.getElementById('correctedContent');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadReportBtn = document.getElementById('downloadReportBtn');

        // Dictionary manager elements
        const incorrectWordInput = document.getElementById('incorrectWord');
        const correctWordInput = document.getElementById('correctWord');
        const addEntryBtn = document.getElementById('addEntryBtn');
        const downloadDictBtn = document.getElementById('downloadDictBtn');
        const entriesList = document.getElementById('entriesList');
        const entryCount = document.getElementById('entryCount');

        // Acronym manager elements
        const acronymShortInput = document.getElementById('acronymShort');
        const acronymFullInput = document.getElementById('acronymFull');
        const addAcronymBtn = document.getElementById('addAcronymBtn');
        const downloadAcronymsBtn = document.getElementById('downloadAcronymsBtn');
        const acronymsList = document.getElementById('acronymsList');
        const acronymCount = document.getElementById('acronymCount');

        // Load custom dictionary entries from localStorage
        function loadCustomEntries() {
            const stored = localStorage.getItem('customDictionary');
            return stored ? JSON.parse(stored) : {};
        }

        function saveCustomEntries(entries) {
            localStorage.setItem('customDictionary', JSON.stringify(entries));
        }

        function getMergedDictionary() {
            const customEntries = loadCustomEntries();
            return { ...dictionary, ...customEntries };
        }

        function updateEntriesList() {
            const customEntries = loadCustomEntries();
            const count = Object.keys(customEntries).length;
            entryCount.textContent = count;

            if (count === 0) {
                entriesList.innerHTML = '<p style="color: #999; font-size: 13px;">No custom additions yet</p>';
                return;
            }

            entriesList.innerHTML = '';
            for (const [incorrect, correct] of Object.entries(customEntries)) {
                const item = document.createElement('div');
                item.className = 'entry-item';
                item.innerHTML = `
                    <span class="entry-text">"${incorrect}" → "${correct}"</span>
                    <button class="entry-delete" data-key="${incorrect}">Delete</button>
                `;
                entriesList.appendChild(item);
            }

            // Add delete handlers
            document.querySelectorAll('.entry-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.target.dataset.key;
                    const customEntries = loadCustomEntries();
                    delete customEntries[key];
                    saveCustomEntries(customEntries);
                    updateEntriesList();
                    // Update the working dictionary
                    dictionary = getMergedDictionary();
                });
            });
        }

        function addDictionaryEntry() {
            const incorrect = incorrectWordInput.value.trim().toLowerCase();
            const correct = correctWordInput.value.trim();

            if (!incorrect || !correct) {
                alert('Please enter both incorrect and correct versions');
                return;
            }

            const customEntries = loadCustomEntries();
            customEntries[incorrect] = correct;
            saveCustomEntries(customEntries);

            // Clear inputs
            incorrectWordInput.value = '';
            correctWordInput.value = '';

            // Update display and working dictionary
            updateEntriesList();
            dictionary = getMergedDictionary();

            alert(`Added: "${incorrect}" → "${correct}"`);
        }

        function downloadMergedDictionary() {
            const merged = getMergedDictionary();
            const json = JSON.stringify(merged, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'dictionary.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Acronym management functions
        function loadCustomAcronyms() {
            const stored = localStorage.getItem('customAcronyms');
            return stored ? JSON.parse(stored) : {};
        }

        function saveCustomAcronyms(acronyms) {
            localStorage.setItem('customAcronyms', JSON.stringify(acronyms));
        }

        function getMergedAcronyms() {
            const customAcronyms = loadCustomAcronyms();
            return { ...ACRONYMS, ...customAcronyms };
        }

        function updateAcronymsList() {
            const customAcronyms = loadCustomAcronyms();
            const count = Object.keys(customAcronyms).length;
            acronymCount.textContent = count;

            if (count === 0) {
                acronymsList.innerHTML = '<p style="color: #999; font-size: 13px;">No custom additions yet</p>';
                return;
            }

            acronymsList.innerHTML = '';
            for (const [short, full] of Object.entries(customAcronyms)) {
                const item = document.createElement('div');
                item.className = 'entry-item';
                item.innerHTML = `
                    <span class="entry-text">"${short}" → "${full}"</span>
                    <button class="entry-delete" data-key="${short}">Delete</button>
                `;
                acronymsList.appendChild(item);
            }

            // Add delete handlers
            document.querySelectorAll('#acronymsList .entry-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.target.dataset.key;
                    const customAcronyms = loadCustomAcronyms();
                    delete customAcronyms[key];
                    saveCustomAcronyms(customAcronyms);
                    updateAcronymsList();
                    // Update the working ACRONYMS
                    ACRONYMS = getMergedAcronyms();
                });
            });
        }

        function addAcronym() {
            const short = acronymShortInput.value.trim().toUpperCase();
            const full = acronymFullInput.value.trim();

            if (!short || !full) {
                alert('Please enter both acronym and full name');
                return;
            }

            const customAcronyms = loadCustomAcronyms();
            customAcronyms[short] = full;
            saveCustomAcronyms(customAcronyms);

            // Clear inputs
            acronymShortInput.value = '';
            acronymFullInput.value = '';

            // Update display and working ACRONYMS
            updateAcronymsList();
            ACRONYMS = getMergedAcronyms();

            alert(`Added: "${short}" → "${full}"`);
        }

        function downloadMergedAcronyms() {
            const merged = getMergedAcronyms();
            const json = JSON.stringify(merged, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'acronyms.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize dictionary with custom entries
        dictionary = getMergedDictionary();
        updateEntriesList();

        // Initialize ACRONYMS with custom entries
        ACRONYMS = getMergedAcronyms();
        updateAcronymsList();

        // Hard-coded filler words to remove
        const FILLER_WORDS = ['uh', 'um', 'uh,', 'um,'];

        // Hard-coded colloquialism replacements
        const COLLOQUIALISMS = {
            'gonna': 'going to',
            'gotta': 'got to',
            "'em": 'them',
            'yeah': 'yes'
        };

        // Load dictionary and acronyms from JSON files on startup
        async function loadDictionaries() {
            try {
                // Load dictionary
                const dictResponse = await fetch('dictionary.json');
                if (dictResponse.ok) {
                    dictionary = await dictResponse.json();
                    console.log(`Loaded ${Object.keys(dictionary).length} dictionary entries`);
                } else {
                    console.warn('Could not load dictionary.json, using empty dictionary');
                }

                // Load acronyms
                const acronymsResponse = await fetch('acronyms.json');
                if (acronymsResponse.ok) {
                    ACRONYMS = await acronymsResponse.json();
                    console.log(`Loaded ${Object.keys(ACRONYMS).length} acronyms`);
                } else {
                    console.warn('Could not load acronyms.json, using empty acronyms');
                }

                // Load custom entries from localStorage and merge
                loadCustomDictionaryEntries();
                loadCustomAcronyms();
            } catch (error) {
                console.error('Error loading dictionaries:', error);
            }
        }

        // Load dictionaries before setting up event listeners
        loadDictionaries().then(() => {
            console.log('Dictionaries loaded, app ready');
        });

        vttFileInput.addEventListener('change', handleVTTFile);
        processBtn.addEventListener('click', processTranscript);
        downloadBtn.addEventListener('click', downloadCorrectedVTT);
        downloadReportBtn.addEventListener('click', downloadReport);
        addEntryBtn.addEventListener('click', addDictionaryEntry);
        downloadDictBtn.addEventListener('click', downloadMergedDictionary);
        addAcronymBtn.addEventListener('click', addAcronym);
        downloadAcronymsBtn.addEventListener('click', downloadMergedAcronyms);

        // Allow Enter key to add dictionary entry
        correctWordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addDictionaryEntry();
        });

        // Allow Enter key to add acronym
        acronymFullInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addAcronym();
        });

        async function handleVTTFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                vttContent = await file.text();
                processBtn.disabled = false;
            }
        }

        function parseVTT(content) {
            const lines = content.split('\n');
            const cues = [];
            let i = 0;

            // Skip header
            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            // Parse cues
            while (i < lines.length) {
                if (lines[i].includes('-->')) {
                    const timeLine = lines[i];
                    const [startTime, endTime] = timeLine.split('-->').map(t => t.trim());

                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        text += (text ? ' ' : '') + lines[i];
                        i++;
                    }

                    // Extract speaker from <v SPEAKER> tag and convert to SPEAKER: format
                    const speakerMatch = text.match(/<v\s+([^>]+)>/);
                    if (speakerMatch) {
                        const speaker = speakerMatch[1].trim();
                        // Remove the <v SPEAKER> tag and add SPEAKER: prefix
                        text = text.replace(/<v\s+[^>]+>/, '').trim();
                        text = `${speaker}: ${text}`;
                    }

                    cues.push({ startTime, endTime, text });
                }
                i++;
            }

            return cues;
        }

        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            const seconds = parseFloat(parts[2]);
            return hours * 3600 + minutes * 60 + seconds;
        }

        function secondsToTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;
        }

        function expandAcronyms(text, changes) {
            // Extract speaker label if present (don't expand acronyms in speaker names)
            const speakerMatch = text.match(/^([A-Z0-9][A-Z0-9\s]*?):\s*/);
            let speakerLabel = '';
            let content = text;

            if (speakerMatch) {
                speakerLabel = speakerMatch[0];
                content = text.substring(speakerMatch[0].length);
            }

            // Find all-caps words (potential acronyms)
            const acronymRegex = /\b([A-Z]{2,})\b/g;
            let match;

            while ((match = acronymRegex.exec(content)) !== null) {
                const acronym = match[1];

                // Skip if already expanded, in exclusions, or not in dictionary
                if (expandedAcronyms.has(acronym) ||
                    ACRONYM_EXCLUSIONS.includes(acronym) ||
                    !ACRONYMS[acronym]) {
                    continue;
                }

                // Expand the acronym on first mention
                const expansion = ACRONYMS[acronym];
                const expandedForm = `${acronym} [${expansion}]`;
                content = content.replace(new RegExp(`\\b${acronym}\\b`, 'g'), expandedForm);

                // Mark as expanded
                expandedAcronyms.add(acronym);
                changes.acronymsExpanded = (changes.acronymsExpanded || 0) + 1;
            }

            return speakerLabel + content;
        }

        // Track proper names across segments
        const markedProperNames = new Set();

        function markProperNames(text, changes) {
            // Skip speaker labels - extract them first
            const speakerMatch = text.match(/^([A-Z0-9][A-Z0-9\s]*?:\s+)/);
            const speakerLabel = speakerMatch ? speakerMatch[1] : '';
            const content = speakerMatch ? text.substring(speakerLabel.length) : text;

            let marked = content;

            // Only mark multi-word names (2-3 consecutive capitalized words)
            // This captures full human names like "Terry Gross", "George Gerbner"
            // while mostly avoiding single-word place names or organizations
            const multiWordPattern = /\b([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\b/g;
            marked = marked.replace(multiWordPattern, (match) => {
                // Skip if it's part of an acronym expansion (contains brackets)
                if (match.includes('[') || match.includes(']')) {
                    return match;
                }

                const lowerMatch = match.toLowerCase();

                // Skip if this name is in the dictionary (keys or values)
                const inDictionary = Object.keys(dictionary).some(key => key.toLowerCase() === lowerMatch) ||
                                    Object.values(dictionary).some(val => val.toLowerCase() === lowerMatch);
                if (inDictionary) {
                    return match;
                }

                // Skip if this name is in the acronyms list (keys or values)
                const inAcronyms = Object.keys(ACRONYMS).some(key => key.toLowerCase() === lowerMatch) ||
                                  Object.values(ACRONYMS).some(val => val.toLowerCase() === lowerMatch);
                if (inAcronyms) {
                    return match;
                }

                // Check if we've seen this name before (case-insensitive)
                if (!markedProperNames.has(lowerMatch)) {
                    markedProperNames.add(lowerMatch);
                    changes.properNamesMarked = (changes.properNamesMarked || 0) + 1;
                    return `{{${match}}}`;
                }
                return match;
            });

            return speakerLabel + marked;
        }

        function applyTextCorrections(text, changes) {
            let corrected = text;

            // Apply dictionary substitutions (case-insensitive)
            for (const [wrong, correct] of Object.entries(dictionary)) {
                const regex = new RegExp('\\b' + wrong.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.dictionaryReplacements += matches.length;
                    corrected = corrected.replace(regex, correct);
                }
            }

            // Remove filler words
            for (const filler of FILLER_WORDS) {
                const regex = new RegExp('\\b' + filler.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.fillerWordsRemoved += matches.length;
                    corrected = corrected.replace(regex, '');
                }
            }

            // Replace colloquialisms
            for (const [colloquial, formal] of Object.entries(COLLOQUIALISMS)) {
                const regex = new RegExp('\\b' + colloquial.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.colloquialismReplacements += matches.length;
                    // Preserve capitalization of the matched word
                    corrected = corrected.replace(regex, (match) => {
                        // If first letter is uppercase, capitalize replacement
                        if (match[0] === match[0].toUpperCase()) {
                            return formal.charAt(0).toUpperCase() + formal.slice(1);
                        }
                        // Otherwise keep lowercase
                        return formal;
                    });
                }
            }

            // Expand acronyms (first mention only)
            corrected = expandAcronyms(corrected, changes);

            // Remove quotation marks and handle capitalization/commas
            const beforeQuotes = corrected;
            let quotesRemoved = 0;

            // Handle STRAIGHT quotes (paired quotes first, then unpaired)
            // Pattern 1: word + comma + space + " + text + " (keep comma)
            corrected = corrected.replace(/(\w)(,\s+)"([^"]+)"/g, (match, word, commaSpace, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return word + commaSpace + capitalized;
            });

            // Pattern 2: word + space + " + text + " (add comma)
            corrected = corrected.replace(/(\w)(\s+)"([^"]+)"/g, (match, word, space, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return word + ',' + space + capitalized;
            });

            // Pattern 3: " at start or after punctuation
            corrected = corrected.replace(/(^|[.!?]\s+)"([^"]+)"/g, (match, prefix, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return prefix + capitalized;
            });

            // Pattern 4: After em-dash (common in dialogue)
            corrected = corrected.replace(/(—\s*)"([^"]+)"/g, (match, dash, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return dash + capitalized;
            });

            // Pattern 5: Remove any remaining unpaired quotes (from VTT segment splits)
            // These occur when a quote spans multiple VTT segments

            // Handle opening quotes mid-sentence: word "Capital -> word capital
            corrected = corrected.replace(/(\w\s+)"([A-Z])/g, (match, before, capitalLetter) => {
                quotesRemoved++;
                return before + capitalLetter.toLowerCase();
            });

            // Handle opening quotes after punctuation: . "Capital -> . Capital (keep capitalized)
            // (No change needed - just remove the quote)
            corrected = corrected.replace(/([.!?,]\s+)"/g, (match, punctuation) => {
                quotesRemoved++;
                return punctuation;
            });

            // Remove any other remaining quotes
            const remainingQuotes = corrected.match(/"/g);
            if (remainingQuotes) {
                corrected = corrected.replace(/"/g, '');
                quotesRemoved += remainingQuotes.length;
            }

            // Handle CURLY quotes (paired quotes first, then unpaired)
            corrected = corrected.replace(/(\w)(,\s+)\u201C([^\u201D]+)\u201D/g, (match, word, commaSpace, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return word + commaSpace + capitalized;
            });

            corrected = corrected.replace(/(\w)(\s+)\u201C([^\u201D]+)\u201D/g, (match, word, space, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return word + ',' + space + capitalized;
            });

            corrected = corrected.replace(/(^|[.!?]\s+)\u201C([^\u201D]+)\u201D/g, (match, prefix, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return prefix + capitalized;
            });

            corrected = corrected.replace(/(—\s*)\u201C([^\u201D]+)\u201D/g, (match, dash, content) => {
                const capitalized = content.charAt(0).toUpperCase() + content.slice(1);
                quotesRemoved += 2;
                return dash + capitalized;
            });

            // Remove any remaining unpaired curly quotes

            // Handle opening curly quotes mid-sentence: word "Capital -> word capital
            corrected = corrected.replace(/(\w\s+)\u201C([A-Z])/g, (match, before, capitalLetter) => {
                quotesRemoved++;
                return before + capitalLetter.toLowerCase();
            });

            // Handle opening curly quotes after punctuation: . "Capital -> . Capital (keep capitalized)
            corrected = corrected.replace(/([.!?,]\s+)\u201C/g, (match, punctuation) => {
                quotesRemoved++;
                return punctuation;
            });

            // Remove any other remaining curly quotes
            const remainingCurlyQuotes = corrected.match(/[\u201C\u201D]/g);
            if (remainingCurlyQuotes) {
                corrected = corrected.replace(/[\u201C\u201D]/g, '');
                quotesRemoved += remainingCurlyQuotes.length;
            }

            if (quotesRemoved > 0) {
                changes.quotesRemoved = (changes.quotesRemoved || 0) + quotesRemoved;
            }

            // Replace double hyphens with em-dash (removing spaces on either side)
            const emDashMatches = corrected.match(/\s*--\s*/g);
            if (emDashMatches) {
                changes.emDashReplacements += emDashMatches.length;
                corrected = corrected.replace(/\s*--\s*/g, '—');
            }

            // Clean up extra spaces
            corrected = corrected.replace(/\s+/g, ' ').trim();

            // Mark proper names on first mention
            corrected = markProperNames(corrected, changes);

            return corrected;
        }

        function capitalizeSpeakerText(text) {
            // Remove hyphen/em-dash after speaker label: "GROSS: - text" → "GROSS: text"
            text = text.replace(/^([A-Z0-9][A-Z0-9\s]*?:\s+)[—-]\s+/, '$1');

            // Capitalize first word after speaker label (unless preceded by em-dash or other punctuation)
            // This should only be called AFTER speaker consolidation
            return text.replace(/^([A-Z0-9][A-Z0-9\s]*?:\s+)([a-z])/, (match, label, firstChar) => {
                // Check what comes after the label
                const afterLabel = text.substring(label.length);
                if (afterLabel.match(/^[—.!?;,]/)) {
                    return match; // Don't capitalize if punctuation follows
                }
                return label + firstChar.toUpperCase();
            });
        }

        function extractSpeaker(text) {
            // Extract speaker name from text like "GROSS: Hello there" or "Q1: Hello there"
            // Match letters, numbers, and spaces before colon
            const match = text.match(/^([A-Z0-9][A-Z0-9\s]*?):\s*/);
            return match ? match[1].trim() : null;
        }

        function removeSpeakerLabel(text) {
            // Remove "SPEAKER: " from the beginning of text
            return text.replace(/^[A-Z0-9][A-Z0-9\s]*?:\s*/, '').trim();
        }

        function filterSpeakerChanges(segments) {
            // Merge consecutive segments from the same speaker
            const result = [];
            let currentSegment = null;

            for (const segment of segments) {
                const speaker = extractSpeaker(segment.text);

                if (!currentSegment || currentSegment.speaker !== speaker) {
                    // Speaker changed, save previous and start new
                    if (currentSegment) {
                        result.push(currentSegment);
                    }
                    currentSegment = {
                        speaker: speaker,
                        text: segment.text, // Keep full text with speaker label
                        startTime: segment.startTime,
                        endTime: segment.endTime,
                        startMs: timeToSeconds(segment.startTime) * 1000,
                        endMs: timeToSeconds(segment.endTime) * 1000
                    };
                } else {
                    // Same speaker, merge text (without repeating speaker label)
                    let textWithoutSpeaker = removeSpeakerLabel(segment.text);

                    // Fix capitalization: if previous text doesn't end with sentence punctuation,
                    // lowercase the first letter of the new text (it's mid-sentence)
                    const currentTextTrimmed = currentSegment.text.trim();
                    const endsWithSentencePunctuation = /[.!?]$/.test(currentTextTrimmed);

                    if (!endsWithSentencePunctuation && textWithoutSpeaker.length > 0) {
                        // Lowercase first character if it's a capital letter
                        textWithoutSpeaker = textWithoutSpeaker.charAt(0).toLowerCase() + textWithoutSpeaker.slice(1);
                    }

                    currentSegment.text += ' ' + textWithoutSpeaker;
                    currentSegment.endTime = segment.endTime;
                    currentSegment.endMs = timeToSeconds(segment.endTime) * 1000;
                }
            }

            // Add final segment
            if (currentSegment) {
                result.push(currentSegment);
            }

            return result;
        }

        function splitTextIntoEqualChunks(text, numChunks) {
            // Split into sentences first
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

            if (sentences.length <= numChunks) {
                // Fewer sentences than chunks needed, split by words
                return splitTextByWords(text, numChunks);
            }

            // Distribute sentences evenly across chunks
            const chunks = [];
            const sentencesPerChunk = Math.ceil(sentences.length / numChunks);

            for (let i = 0; i < numChunks; i++) {
                const start = i * sentencesPerChunk;
                const end = Math.min(start + sentencesPerChunk, sentences.length);
                const chunk = sentences.slice(start, end).join('').trim();
                if (chunk) {
                    chunks.push(chunk);
                }
            }

            return chunks.length > 0 ? chunks : [text];
        }

        function splitTextByWords(text, numChunks) {
            const words = text.split(/\s+/);
            const wordsPerChunk = Math.ceil(words.length / numChunks);
            const chunks = [];

            for (let i = 0; i < numChunks; i++) {
                const start = i * wordsPerChunk;
                const end = Math.min(start + wordsPerChunk, words.length);
                const chunk = words.slice(start, end).join(' ').trim();
                if (chunk) {
                    chunks.push(chunk);
                }
            }

            return chunks.length > 0 ? chunks : [text];
        }

        function splitLongSegments(segments) {
            const result = [];
            const maxDuration = 120000; // 2 minutes in milliseconds

            for (const segment of segments) {
                const duration = segment.endMs - segment.startMs;

                if (duration <= maxDuration) {
                    result.push(segment);
                } else {
                    // Calculate how many ~2-minute chunks we need
                    const numChunks = Math.ceil(duration / maxDuration);

                    // Split text into that many chunks
                    const textChunks = splitTextIntoEqualChunks(segment.text, numChunks);

                    // Assign 2 minutes (or remaining time) to each chunk
                    textChunks.forEach((chunkText, index) => {
                        const startMs = segment.startMs + (index * maxDuration);
                        const endMs = Math.min(startMs + maxDuration, segment.endMs);

                        result.push({
                            speaker: segment.speaker,
                            text: chunkText,
                            startTime: secondsToTime(startMs / 1000),
                            endTime: secondsToTime(endMs / 1000),
                            startMs,
                            endMs
                        });
                    });
                }
            }

            return result;
        }

        function restructureTimestamps(cues) {
            // First: Add speaker info and convert to segments with milliseconds
            const segments = cues.map(cue => ({
                text: cue.text,
                startTime: cue.startTime,
                endTime: cue.endTime
            }));

            // Second: Merge consecutive segments from same speaker
            const merged = filterSpeakerChanges(segments);

            // Third: Split any segments longer than 2 minutes
            const split = splitLongSegments(merged);

            // Fourth: Capitalize first word after speaker labels (after consolidation)
            const capitalized = split.map(seg => ({
                ...seg,
                text: capitalizeSpeakerText(seg.text)
            }));

            // Convert back to cue format
            return capitalized.map(seg => ({
                startTime: seg.startTime,
                endTime: seg.endTime,
                text: seg.text
            }));
        }

        function processTranscript() {
            if (!vttContent) return;

            // Reset tracking for new transcript
            expandedAcronyms.clear();
            markedProperNames.clear();

            const changes = {
                dictionaryReplacements: 0,
                fillerWordsRemoved: 0,
                colloquialismReplacements: 0,
                acronymsExpanded: 0,
                quotesRemoved: 0,
                emDashReplacements: 0,
                timestampBlocks: 0,
                segmentsSplit: 0
            };

            try {
                // Parse VTT
                const cues = parseVTT(vttContent);
                changes.originalCues = cues.length;

                // Apply text corrections to each cue
                const correctedCues = cues.map(cue => ({
                    ...cue,
                    text: applyTextCorrections(cue.text, changes)
                }));

                // Restructure timestamps
                const restructuredCues = restructureTimestamps(correctedCues);
                changes.timestampBlocks = restructuredCues.length;
                changes.segmentsSplit = changes.timestampBlocks - changes.originalCues;

                // Generate new VTT
                correctedVTT = 'WEBVTT\n\n' + restructuredCues.map((cue, index) =>
                    `${index + 1}\n${cue.startTime} --> ${cue.endTime}\n${cue.text}\n`
                ).join('\n');

                // Generate report
                changeReport = `VTT Transcript Cleaner - Processing Report
Generated: ${new Date().toLocaleString()}
Original File: ${originalFilename}

Changes Applied:
- Dictionary substitutions: ${changes.dictionaryReplacements}
- Filler words removed: ${changes.fillerWordsRemoved}
- Colloquialisms replaced: ${changes.colloquialismReplacements}
- Acronyms expanded: ${changes.acronymsExpanded}
- Proper names marked (first mention): ${changes.properNamesMarked || 0}
- Quotation marks removed: ${changes.quotesRemoved}
- Em-dashes replaced: ${changes.emDashReplacements}
- Original cue blocks: ${changes.originalCues}
- New timestamp blocks: ${changes.timestampBlocks}
- Segments restructured: ${changes.segmentsSplit}

Dictionary entries: ${Object.keys(dictionary).length}
Acronym entries: ${Object.keys(ACRONYMS).length}
`;

                // Display results
                displayResults(changes);

            } catch (error) {
                alert('Error processing transcript: ' + error.message);
                console.error(error);
            }
        }

        function extractTextFromVTT(vttContent) {
            // Extract only the spoken text, ignoring timestamps and cue numbers
            const lines = vttContent.split('\n');
            const textLines = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Skip empty lines, WEBVTT header, cue numbers, and timestamp lines
                if (line &&
                    line !== 'WEBVTT' &&
                    !line.match(/^\d+$/) &&
                    !line.includes('-->')) {
                    textLines.push(line);
                }
            }

            return textLines.join('\n');
        }

        function highlightDiff(originalVTT, correctedVTT) {
            // Extract just the text content from both VTT files
            const originalText = extractTextFromVTT(originalVTT);
            let correctedText = extractTextFromVTT(correctedVTT);

            // Extract proper names before removing markers
            const properNames = [];
            correctedText = correctedText.replace(/\{\{([^}]+)\}\}/g, (match, name) => {
                properNames.push(name);
                return name; // Remove brackets, keep just the name
            });

            // Split into words (preserving spaces and punctuation)
            const originalWords = originalText.split(/(\s+|[.,;:!?])/);
            const correctedWords = correctedText.split(/(\s+|[.,;:!?])/);

            let highlightedOriginal = '';
            let highlightedCorrected = '';

            // Use a simple longest common subsequence approach
            let i = 0, j = 0;

            while (i < originalWords.length || j < correctedWords.length) {
                const origWord = originalWords[i] || '';
                const corrWord = correctedWords[j] || '';

                if (origWord === corrWord) {
                    // Words match
                    highlightedOriginal += escapeHtml(origWord);
                    highlightedCorrected += escapeHtml(corrWord);
                    i++;
                    j++;
                } else {
                    // Words differ - look ahead to see if we can find a match
                    let foundMatch = false;

                    // Check if original word appears later in corrected (insertion)
                    for (let k = j + 1; k < Math.min(j + 5, correctedWords.length); k++) {
                        if (originalWords[i] === correctedWords[k]) {
                            // Found a match - corrected has insertions
                            while (j < k) {
                                highlightedCorrected += `<span class="diff-added">${escapeHtml(correctedWords[j])}</span>`;
                                j++;
                            }
                            foundMatch = true;
                            break;
                        }
                    }

                    if (!foundMatch) {
                        // Check if corrected word appears later in original (deletion)
                        for (let k = i + 1; k < Math.min(i + 5, originalWords.length); k++) {
                            if (correctedWords[j] === originalWords[k]) {
                                // Found a match - original has deletions
                                while (i < k) {
                                    highlightedOriginal += `<span class="diff-deleted">${escapeHtml(originalWords[i])}</span>`;
                                    i++;
                                }
                                foundMatch = true;
                                break;
                            }
                        }
                    }

                    if (!foundMatch) {
                        // No match found - treat as substitution
                        if (origWord) {
                            highlightedOriginal += `<span class="diff-deleted">${escapeHtml(origWord)}</span>`;
                            i++;
                        }
                        if (corrWord) {
                            highlightedCorrected += `<span class="diff-added">${escapeHtml(corrWord)}</span>`;
                            j++;
                        }
                    }
                }
            }

            // Highlight proper names in blue (without brackets)
            for (const name of properNames) {
                // Escape the name for use in regex
                const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Replace the name with blue-highlighted version
                const regex = new RegExp(`\\b${escapedName}\\b`, 'g');
                highlightedCorrected = highlightedCorrected.replace(regex, `<span class="proper-name">${escapeHtml(name)}</span>`);
            }

            // Convert newlines to <br> tags for proper display
            highlightedOriginal = highlightedOriginal.replace(/\n/g, '<br>');
            highlightedCorrected = highlightedCorrected.replace(/\n/g, '<br>');

            return {
                original: highlightedOriginal,
                corrected: highlightedCorrected
            };
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function displayResults(changes) {
            // Show report
            reportDiv.innerHTML = `
                <h3>Processing Complete</h3>
                <ul>
                    <li>Dictionary substitutions: ${changes.dictionaryReplacements}</li>
                    <li>Filler words removed: ${changes.fillerWordsRemoved}</li>
                    <li>Colloquialisms replaced: ${changes.colloquialismReplacements}</li>
                    <li>Acronyms expanded: ${changes.acronymsExpanded}</li>
                    <li>Quotation marks removed: ${changes.quotesRemoved}</li>
                    <li>Em-dashes replaced: ${changes.emDashReplacements}</li>
                    <li>Original cue blocks: ${changes.originalCues}</li>
                    <li>New timestamp blocks: ${changes.timestampBlocks}</li>
                    <li>Segments restructured: ${changes.segmentsSplit}</li>
                </ul>
            `;

            // Show diff with highlighting
            const diff = highlightDiff(vttContent, correctedVTT);
            originalContentDiv.innerHTML = diff.original;
            correctedContentDiv.innerHTML = diff.corrected;

            // Show results section
            resultsDiv.classList.add('visible');

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function downloadCorrectedVTT() {
            if (!correctedVTT) return;

            const filename = originalFilename.replace('.vtt', '_corrected.vtt');
            const blob = new Blob([correctedVTT], { type: 'text/vtt' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadReport() {
            if (!changeReport) return;

            const filename = originalFilename.replace('.vtt', '_report.txt');
            const blob = new Blob([changeReport], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
