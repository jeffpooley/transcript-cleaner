<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTT Transcript Cleaner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            background-color: #f5f5f5;
        }

        header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .file-input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        input[type="file"] {
            display: block;
            margin-bottom: 10px;
            padding: 8px;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background-color: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #0051D5;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .results {
            display: none;
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .results.visible {
            display: block;
        }

        .report {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #007AFF;
        }

        .report h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .report ul {
            list-style-position: inside;
            color: #666;
        }

        .report li {
            margin-bottom: 5px;
        }

        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .diff-panel {
            background: #f9f9f9;
            border-radius: 6px;
            overflow: hidden;
        }

        .diff-header {
            background: #333;
            color: white;
            padding: 10px 15px;
            font-weight: 500;
        }

        .diff-content {
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .original {
            border: 2px solid #FF3B30;
        }

        .corrected {
            border: 2px solid #34C759;
        }

        .download-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .secondary-button {
            background-color: #8E8E93;
        }

        .secondary-button:hover {
            background-color: #636366;
        }

        .error {
            background-color: #FFEBEE;
            color: #C62828;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #C62828;
        }

        .info {
            background-color: #E3F2FD;
            color: #1565C0;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #1565C0;
        }
    </style>
</head>
<body>
    <header>
        <h1>VTT Transcript Cleaner</h1>
        <p class="subtitle">Clean and restructure oral history transcripts with speaker turn timestamps</p>
    </header>

    <div class="controls">
        <div class="file-input-group">
            <label for="vttFile">Select VTT Transcript File:</label>
            <input type="file" id="vttFile" accept=".vtt">
        </div>

        <div class="file-input-group">
            <label for="dictFile">Select Dictionary File (optional):</label>
            <input type="file" id="dictFile" accept=".json">
        </div>

        <button id="processBtn" disabled>Process Transcript</button>
    </div>

    <div id="results" class="results">
        <div id="report" class="report"></div>

        <div class="diff-container">
            <div class="diff-panel original">
                <div class="diff-header">Original</div>
                <div id="originalContent" class="diff-content"></div>
            </div>
            <div class="diff-panel corrected">
                <div class="diff-header">Corrected</div>
                <div id="correctedContent" class="diff-content"></div>
            </div>
        </div>

        <div class="download-buttons">
            <button id="downloadBtn">Download Corrected VTT</button>
            <button id="downloadReportBtn" class="secondary-button">Download Report</button>
        </div>
    </div>

    <script>
        let vttContent = null;
        let dictionary = {};
        let correctedVTT = null;
        let changeReport = null;
        let originalFilename = '';

        const vttFileInput = document.getElementById('vttFile');
        const dictFileInput = document.getElementById('dictFile');
        const processBtn = document.getElementById('processBtn');
        const resultsDiv = document.getElementById('results');
        const reportDiv = document.getElementById('report');
        const originalContentDiv = document.getElementById('originalContent');
        const correctedContentDiv = document.getElementById('correctedContent');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadReportBtn = document.getElementById('downloadReportBtn');

        // Hard-coded filler words to remove
        const FILLER_WORDS = ['uh', 'um', 'uh,', 'um,'];

        // Hard-coded colloquialism replacements
        const COLLOQUIALISMS = {
            'gonna': 'going to',
            'gotta': 'got to',
            "'em": 'them'
        };

        vttFileInput.addEventListener('change', handleVTTFile);
        dictFileInput.addEventListener('change', handleDictFile);
        processBtn.addEventListener('click', processTranscript);
        downloadBtn.addEventListener('click', downloadCorrectedVTT);
        downloadReportBtn.addEventListener('click', downloadReport);

        async function handleVTTFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                vttContent = await file.text();
                processBtn.disabled = false;
            }
        }

        async function handleDictFile(event) {
            const file = event.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    dictionary = JSON.parse(text);
                    console.log('Dictionary loaded:', Object.keys(dictionary).length, 'entries');
                } catch (error) {
                    alert('Error loading dictionary file: ' + error.message);
                    dictionary = {};
                }
            }
        }

        function parseVTT(content) {
            const lines = content.split('\n');
            const cues = [];
            let i = 0;

            // Skip header
            while (i < lines.length && !lines[i].includes('-->')) {
                i++;
            }

            // Parse cues
            while (i < lines.length) {
                if (lines[i].includes('-->')) {
                    const timeLine = lines[i];
                    const [startTime, endTime] = timeLine.split('-->').map(t => t.trim());

                    i++;
                    let text = '';
                    while (i < lines.length && lines[i].trim() !== '') {
                        text += (text ? ' ' : '') + lines[i];
                        i++;
                    }

                    // Extract speaker from <v SPEAKER> tag and convert to SPEAKER: format
                    const speakerMatch = text.match(/<v\s+([^>]+)>/);
                    if (speakerMatch) {
                        const speaker = speakerMatch[1].trim();
                        // Remove the <v SPEAKER> tag and add SPEAKER: prefix
                        text = text.replace(/<v\s+[^>]+>/, '').trim();
                        text = `${speaker}: ${text}`;
                    }

                    cues.push({ startTime, endTime, text });
                }
                i++;
            }

            return cues;
        }

        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            const hours = parseInt(parts[0]);
            const minutes = parseInt(parts[1]);
            const seconds = parseFloat(parts[2]);
            return hours * 3600 + minutes * 60 + seconds;
        }

        function secondsToTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = (seconds % 60).toFixed(3);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.padStart(6, '0')}`;
        }

        function applyTextCorrections(text, changes) {
            let corrected = text;

            // Apply dictionary substitutions (case-insensitive)
            for (const [wrong, correct] of Object.entries(dictionary)) {
                const regex = new RegExp('\\b' + wrong.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.dictionaryReplacements += matches.length;
                    corrected = corrected.replace(regex, correct);
                }
            }

            // Remove filler words
            for (const filler of FILLER_WORDS) {
                const regex = new RegExp('\\b' + filler.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.fillerWordsRemoved += matches.length;
                    corrected = corrected.replace(regex, '');
                }
            }

            // Replace colloquialisms
            for (const [colloquial, formal] of Object.entries(COLLOQUIALISMS)) {
                const regex = new RegExp('\\b' + colloquial.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                const matches = corrected.match(regex);
                if (matches) {
                    changes.colloquialismReplacements += matches.length;
                    corrected = corrected.replace(regex, formal);
                }
            }

            // Replace double hyphens with em-dash (removing spaces on either side)
            const emDashMatches = corrected.match(/\s*--\s*/g);
            if (emDashMatches) {
                changes.emDashReplacements += emDashMatches.length;
                corrected = corrected.replace(/\s*--\s*/g, 'â€”');
            }

            // Clean up extra spaces
            corrected = corrected.replace(/\s+/g, ' ').trim();

            return corrected;
        }

        function extractSpeaker(text) {
            // Extract speaker name from text like "GROSS: Hello there" or "Q1: Hello there"
            // Match letters, numbers, and spaces before colon
            const match = text.match(/^([A-Z0-9][A-Z0-9\s]*?):\s*/);
            return match ? match[1].trim() : null;
        }

        function removeSpeakerLabel(text) {
            // Remove "SPEAKER: " from the beginning of text
            return text.replace(/^[A-Z0-9][A-Z0-9\s]*?:\s*/, '').trim();
        }

        function filterSpeakerChanges(segments) {
            // Merge consecutive segments from the same speaker
            const result = [];
            let currentSegment = null;

            for (const segment of segments) {
                const speaker = extractSpeaker(segment.text);

                if (!currentSegment || currentSegment.speaker !== speaker) {
                    // Speaker changed, save previous and start new
                    if (currentSegment) {
                        result.push(currentSegment);
                    }
                    currentSegment = {
                        speaker: speaker,
                        text: segment.text, // Keep full text with speaker label
                        startTime: segment.startTime,
                        endTime: segment.endTime,
                        startMs: timeToSeconds(segment.startTime) * 1000,
                        endMs: timeToSeconds(segment.endTime) * 1000
                    };
                } else {
                    // Same speaker, merge text (without repeating speaker label)
                    const textWithoutSpeaker = removeSpeakerLabel(segment.text);
                    currentSegment.text += ' ' + textWithoutSpeaker;
                    currentSegment.endTime = segment.endTime;
                    currentSegment.endMs = timeToSeconds(segment.endTime) * 1000;
                }
            }

            // Add final segment
            if (currentSegment) {
                result.push(currentSegment);
            }

            return result;
        }

        function splitTextIntoEqualChunks(text, numChunks) {
            // Split into sentences first
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

            if (sentences.length <= numChunks) {
                // Fewer sentences than chunks needed, split by words
                return splitTextByWords(text, numChunks);
            }

            // Distribute sentences evenly across chunks
            const chunks = [];
            const sentencesPerChunk = Math.ceil(sentences.length / numChunks);

            for (let i = 0; i < numChunks; i++) {
                const start = i * sentencesPerChunk;
                const end = Math.min(start + sentencesPerChunk, sentences.length);
                const chunk = sentences.slice(start, end).join('').trim();
                if (chunk) {
                    chunks.push(chunk);
                }
            }

            return chunks.length > 0 ? chunks : [text];
        }

        function splitTextByWords(text, numChunks) {
            const words = text.split(/\s+/);
            const wordsPerChunk = Math.ceil(words.length / numChunks);
            const chunks = [];

            for (let i = 0; i < numChunks; i++) {
                const start = i * wordsPerChunk;
                const end = Math.min(start + wordsPerChunk, words.length);
                const chunk = words.slice(start, end).join(' ').trim();
                if (chunk) {
                    chunks.push(chunk);
                }
            }

            return chunks.length > 0 ? chunks : [text];
        }

        function splitLongSegments(segments) {
            const result = [];
            const maxDuration = 120000; // 2 minutes in milliseconds

            for (const segment of segments) {
                const duration = segment.endMs - segment.startMs;

                if (duration <= maxDuration) {
                    result.push(segment);
                } else {
                    // Calculate how many ~2-minute chunks we need
                    const numChunks = Math.ceil(duration / maxDuration);

                    // Split text into that many chunks
                    const textChunks = splitTextIntoEqualChunks(segment.text, numChunks);

                    // Assign 2 minutes (or remaining time) to each chunk
                    textChunks.forEach((chunkText, index) => {
                        const startMs = segment.startMs + (index * maxDuration);
                        const endMs = Math.min(startMs + maxDuration, segment.endMs);

                        result.push({
                            speaker: segment.speaker,
                            text: chunkText,
                            startTime: secondsToTime(startMs / 1000),
                            endTime: secondsToTime(endMs / 1000),
                            startMs,
                            endMs
                        });
                    });
                }
            }

            return result;
        }

        function restructureTimestamps(cues) {
            // First: Add speaker info and convert to segments with milliseconds
            const segments = cues.map(cue => ({
                text: cue.text,
                startTime: cue.startTime,
                endTime: cue.endTime
            }));

            // Second: Merge consecutive segments from same speaker
            const merged = filterSpeakerChanges(segments);

            // Third: Split any segments longer than 2 minutes
            const split = splitLongSegments(merged);

            // Convert back to cue format
            return split.map(seg => ({
                startTime: seg.startTime,
                endTime: seg.endTime,
                text: seg.text
            }));
        }

        function processTranscript() {
            if (!vttContent) return;

            const changes = {
                dictionaryReplacements: 0,
                fillerWordsRemoved: 0,
                colloquialismReplacements: 0,
                emDashReplacements: 0,
                timestampBlocks: 0,
                segmentsSplit: 0
            };

            try {
                // Parse VTT
                const cues = parseVTT(vttContent);
                changes.originalCues = cues.length;

                // Apply text corrections to each cue
                const correctedCues = cues.map(cue => ({
                    ...cue,
                    text: applyTextCorrections(cue.text, changes)
                }));

                // Restructure timestamps
                const restructuredCues = restructureTimestamps(correctedCues);
                changes.timestampBlocks = restructuredCues.length;
                changes.segmentsSplit = changes.timestampBlocks - changes.originalCues;

                // Generate new VTT
                correctedVTT = 'WEBVTT\n\n' + restructuredCues.map((cue, index) =>
                    `${index + 1}\n${cue.startTime} --> ${cue.endTime}\n${cue.text}\n`
                ).join('\n');

                // Generate report
                changeReport = `VTT Transcript Cleaner - Processing Report
Generated: ${new Date().toLocaleString()}
Original File: ${originalFilename}

Changes Applied:
- Dictionary substitutions: ${changes.dictionaryReplacements}
- Filler words removed: ${changes.fillerWordsRemoved}
- Colloquialisms replaced: ${changes.colloquialismReplacements}
- Em-dashes replaced: ${changes.emDashReplacements}
- Original cue blocks: ${changes.originalCues}
- New timestamp blocks: ${changes.timestampBlocks}
- Segments restructured: ${changes.segmentsSplit}

Dictionary entries used: ${Object.keys(dictionary).length}
`;

                // Display results
                displayResults(changes);

            } catch (error) {
                alert('Error processing transcript: ' + error.message);
                console.error(error);
            }
        }

        function displayResults(changes) {
            // Show report
            reportDiv.innerHTML = `
                <h3>Processing Complete</h3>
                <ul>
                    <li>Dictionary substitutions: ${changes.dictionaryReplacements}</li>
                    <li>Filler words removed: ${changes.fillerWordsRemoved}</li>
                    <li>Colloquialisms replaced: ${changes.colloquialismReplacements}</li>
                    <li>Em-dashes replaced: ${changes.emDashReplacements}</li>
                    <li>Original cue blocks: ${changes.originalCues}</li>
                    <li>New timestamp blocks: ${changes.timestampBlocks}</li>
                    <li>Segments restructured: ${changes.segmentsSplit}</li>
                </ul>
            `;

            // Show diff
            originalContentDiv.textContent = vttContent;
            correctedContentDiv.textContent = correctedVTT;

            // Show results section
            resultsDiv.classList.add('visible');

            // Scroll to results
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function downloadCorrectedVTT() {
            if (!correctedVTT) return;

            const filename = originalFilename.replace('.vtt', '_corrected.vtt');
            const blob = new Blob([correctedVTT], { type: 'text/vtt' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadReport() {
            if (!changeReport) return;

            const filename = originalFilename.replace('.vtt', '_report.txt');
            const blob = new Blob([changeReport], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
